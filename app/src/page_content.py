import pandas as pd
import streamlit as st
import requests
from requests.exceptions import MissingSchema
from io import BytesIO

from src.processing import get_image_url, get_preview_url, return_image_from_url
from src.utils import convert_fractional_time


def sidebar():
    st.sidebar.write("## Recommendation info")

    # We get number of recommendations
    n_recommendations = st.sidebar.selectbox("Number of recommendations", (1, 3, 5))

    # We check if the key must be the same
    arg_key = st.sidebar.checkbox("Keep key the same")

    # We get a specific bpm range
    col_left, col_right = st.columns(2)
    with col_left:
        bpm_minimum = st.sidebar.number_input("Minimum BPM", value=100)
    with col_right:
        bpm_maximum = st.sidebar.number_input("Maximum BPM", value=200)
    arg_bpm = (bpm_minimum, bpm_maximum)

    return (n_recommendations, arg_key, arg_bpm)


def head_introduction():
    st.markdown("""
        <h1 style='text-align: center; margin-bottom: -35px;'>
        Tracklist Generator
        </h1>
    """, unsafe_allow_html=True
                )

    st.caption("""
        <p style='text-align: center'>
        by <a href='https://github.com/garsdal'>Garsdal</a>
        </p>
    """, unsafe_allow_html=True
               )


def head_recommendations():
    st.markdown("""
        <h1 style='text-align: center; margin-bottom: -35px;'>
        Recommendations
        </h1>
    """, unsafe_allow_html=True
                )

    st.caption("""
        <p style='text-align: center'>
        Generated by AI Machine Learning AlphaRecommender
        </p>
    """, unsafe_allow_html=True
               )


def head_tracklist():
    st.markdown("""
        <h1 style='text-align: center; margin-bottom: -35px;'>
        Tracklist
        </h1>
    """, unsafe_allow_html=True
                )

    st.caption("""
        <p style='text-align: center'>
        Your current playlist
        </p>
    """, unsafe_allow_html=True
               )


def body_input_spotify_url():
    # We create a text input
    track_url = st.text_input("Input Spotify URL:",
                              label_visibility="visible",
                              value="https://open.spotify.com/track/60GwMZeymeZYj7GiEzHQ7d?si=9c8ea96aad9e4da4",
                              placeholder="https://open.spotify.com/track/60GwMZeymeZYj7GiEzHQ7d?si=9c8ea96aad9e4da4")

    return track_url


def body_selection(response, df_artist_track_features, key_mapping, mode_mapping):
    artist_name = df_artist_track_features.index[0]
    track_name = df_artist_track_features["track_name"][0]

    # We grab the track image and display it
    image_url = get_image_url(response)
    img = return_image_from_url(image_url)

    # We print the track_features
    f1, f2, f3, f4, f5 = st.columns(5)

    with f1:
        key_numeric = int(df_artist_track_features['key'])
        key_string = key_mapping[str(key_numeric)]
        st.metric("Key:", key_string)
    with f2:
        mode_numeric = int(df_artist_track_features['mode'])
        mode_string = mode_mapping[str(mode_numeric)]
        st.metric("Mode:", mode_string)
    with f3:
        # BPM can come in the format 120.99 and 120.99.00
        bpm = df_artist_track_features['tempo'].values[0]
        st.metric("BPM:", round(float(bpm), 1))
    with f4:
        length_minutes_decimal = int(df_artist_track_features['duration_ms'].values[0])/(60*1000)
        length_minutes_seconds = convert_fractional_time(length_minutes_decimal)
        st.metric("Length:", length_minutes_seconds)
    with f5:
        energy = df_artist_track_features['energy'].values[0]
        st.metric("Energy:", round(float(energy), 2))

    # We grab the track preview and play it
    preview_url = get_preview_url(response)

    # We get the data
    try:
        response_audio = requests.get(preview_url)
        audio_bytes_io = BytesIO(response_audio.content)

        # We create a audio player
        _, col_audio_mid, _ = st.columns(3)
        with col_audio_mid:
            st.audio(audio_bytes_io)
    except MissingSchema:
        # We create a audio player
        _, col_audio_mid, _ = st.columns(3)
        with col_audio_mid:
            st.error("No audio preview available")

    # We print the image
    _, col_mid, _ = st.columns(3)
    with col_mid:
        st.image(img, caption=f' {artist_name} - {track_name}')


def add_artist_track_features_to_tracklist(artist_track_features):
    st.session_state.tracklist.append(artist_track_features)
    st.session_state.recommendation = artist_track_features


def body_recommendation(response, df_artist_track_features, key_mapping, mode_mapping):
    artist_name = df_artist_track_features.index[0]
    track_name = df_artist_track_features["track_name"][0]

    # We get the most important features (COULD BE PUT IN UTILS FCT)
    key_numeric = int(df_artist_track_features['key'])
    key_string = key_mapping[str(key_numeric)]

    mode_numeric = int(df_artist_track_features['mode'])
    mode_string = mode_mapping[str(mode_numeric)]

    # BPM can come in the format 120.99 and 120.99.00
    bpm = round(df_artist_track_features['tempo'].values[0], 1)

    # We grab the track image and display it
    image_url = get_image_url(response)
    img = return_image_from_url(image_url)

    # We grab the preview and provide an audio player
    preview_url = get_preview_url(response)

    # We get the data
    try:
        # We get the data
        response_audio = requests.get(preview_url)
        audio_bytes_io = BytesIO(response_audio.content)

        # We show the user the player
        st.audio(audio_bytes_io)
    except MissingSchema:
        st.error("No audio preview available")

    # We present the user a button
    click = st.button("Select as next track", key=artist_name,
                      on_click=add_artist_track_features_to_tracklist, args=[df_artist_track_features])

    # We show the user the image
    st.image(img, caption=f' {artist_name} - {track_name} | {key_string} | {mode_string} | {bpm}')

    return click


def body_tracklist():
    df_tracklist = pd.concat(st.session_state.tracklist)

    st.dataframe(df_tracklist)